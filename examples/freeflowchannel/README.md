<!-- Important: This file has been automatically generated by generate_example_docs.py. Do not edit this file directly! -->

# Free flow through a channel

__You learn how to__

* solve a free-flow channel problem
* set outflow boundary conditions in the free-flow context

__Results__. In this example we will obtain the following stationary velocity profile:

![](./img/velocity.png)

__Table of contents__. This description is structured as follows:

[[_TOC_]]

## Mathematical model
In this example, the Stokes model for stationary and incompressible single phase flow is considered.
Thus, the momentum balance equations

```math
- \nabla\cdot\left(\mu\left(\nabla\boldsymbol{u}+\nabla\boldsymbol{u}^{\text{T}}\right)\right)+ \nabla p = 0
```

and the mass balance

```math
\nabla \cdot \left(\boldsymbol{u}\right) =0
```

are solved, where $`\varrho`$ and $`\mu`$ are the density and viscosity of the fluid,
$`\boldsymbol{u}`$ is the fluid velocity and $`p`$ is the pressure. Here, we use constant fluid
properties with $`\varrho = 1~\frac{\text{kg}}{\text{m}^3}`$ and $`\mu = 1~\text{Pa}\text{s}`$.
Furthermore, isothermal conditions with a homogeneous temperature distribution of $`T=10^\circ C`$ are assumed.

All equations are discretized with the staggered-grid finite-volume scheme as spatial discretization
with pressures and velocity components as primary variables. For details on the discretization scheme,
have a look at the DuMu<sup>x</sup> [documentation](https://dumux.org/docs/doxygen/master/group___discretization.html).

## Problem set-up
This example considers stationary flow of a fluid between two parallel solid plates in two dimensions.
Flow is enforced from left to right by prescribing an inflow velocity of $` v = 1~\frac{\text{m}}{\text{s}} `$
on the left boundary, while a fixed pressure of $`p = 1.1 \, \text{bar}`$ and a zero velocity gradient
in x-direction are prescribed on the right boundary. On the top and bottom boundaries, no-slip
conditions are applied, which cause a parabolic velocity profile to develop along the channel.
Take a look at Figure 1 for an illustration of the domain and the boundary conditions.

<figure>
    <center>
        <img src="img/setup.png" alt="Free-flow setup" width="80%"/>
        <figcaption> <b> Fig.1 </b> - Setup for the free flow problem.</figcaption>
    </center>
</figure>

# Implementation

## Folder layout and files

```
└── freeflowchannel/
    ├── CMakeLists.txt          -> build system file
    ├── main.cc                 -> main program flow
    ├── params.input            -> runtime parameters
    ├── properties.hh           -> compile time configuration
    └── problem.hh              -> boundary & initial conditions
```


## Compile-time settings (`properties.hh`)

In this file, the type tag used for this simulation (`TTag::ChannelExample`) is defined.
As this is a coupled problem we also define type tags for the two subproblems
`TTag::ChannelExampleMass` and `TTag::ChannelExampleMomentum`. We then specialize properties
(compile time options) to the needs of the desired setup for the respective type tags.


<details open>
<summary><b>Click to hide/show the file documentation</b> (or inspect the [source code](properties.hh))</summary>


### Includes
<details><summary> Click to show includes</summary>

The `NavierStokesMomentum` and `NavierStokesMassOneP` type tags specialize most of the properties
required for Navier-Stokes single-phase flow simulations in DuMu<sup>x</sup>. We will use this in
the following to inherit the respective properties and subsequently specialize those properties
for our type tags, which we want to modify or for which no meaningful default can be set.

```cpp
#include <dumux/freeflow/navierstokes/momentum/fcstaggered/model.hh>
#include <dumux/freeflow/navierstokes/mass/1p/model.hh>
#include <dumux/freeflow/navierstokes/momentum/problem.hh>
#include <dumux/freeflow/navierstokes/mass/problem.hh>
#include <dumux/multidomain/traits.hh>
#include <dumux/multidomain/freeflow/couplingmanager.hh>
```

We want to use `YaspGrid`, an implementation of the dune grid interface for structured grids:

```cpp
#include <dune/grid/yaspgrid.hh>
```

In this example, we want to discretize the momentum and mass balances with the staggered-grid and
cell-centered finite volume discretization schemes, respectively:

```cpp
#include <dumux/discretization/fcstaggered.hh>
#include <dumux/discretization/cctpfa.hh>
```

The fluid properties are specified in the following headers (we use a liquid with constant properties as the fluid phase):

```cpp
#include <dumux/material/fluidsystems/1pliquid.hh>
#include <dumux/material/components/constant.hh>
```

We include the problem header used for this simulation.

```cpp
#include "problem.hh"
```

</details>

### Type tag definition

We define a type tag for our simulation with the name `ChannelExample` as well as type tags for
the momentum and mass subproblems. Shared properties can be specialized to `ChannelExample` and
will be inherited by the subproblems' type tags.
These inherit the properties specialized for the physical models `NavierStokesMomentum` and
`NavierStokesMassOneP` as well as the discretization methods `FaceCenteredStaggeredModel`
and `CCTpfaModel` respectively.
This way, most of the properties required for Navier-Stokes single-phase flow simulations
using the staggered-grid scheme are conveniently specialized for our new type tag.
However, some properties depend on user choices and no meaningful default value can be set.
Those properties will be addressed later in this file.
Please note that, in this example, we actually want to solve the Stokes instead of the
Navier-Stokes equations. This can be achieved at runtime by setting the parameter
`Problem.EnableInertiaTerms = false`. Have a look at the input file `params.input`
to see how this is done in this example.

```cpp
// We enter the namespace `Dumux::Properties` in order to import the entire `Dumux` namespace for general use:
namespace Dumux::Properties {

// declaration of the `ChannelExample` type tag for the single-phase flow problem
namespace TTag {
struct ChannelExample {};
struct ChannelExampleMomentum { using InheritsFrom = std::tuple<ChannelExample, NavierStokesMomentum, FaceCenteredStaggeredModel>; };
struct ChannelExampleMass { using InheritsFrom = std::tuple<ChannelExample, NavierStokesMassOneP, CCTpfaModel>; };
} // namespace TTag
```

### Property specializations

In the following piece of code, mandatory properties for which no meaningful default can be set,
are specialized for our type tag `ChannelExample` or the appropriate type tag of a subproblem.

```cpp
// This sets the grid type used for the simulation. Here, we use a structured 2D grid.
template<class TypeTag>
struct Grid<TypeTag, TTag::ChannelExample> { using type = Dune::YaspGrid<2>; };

// This sets our problem type (see `problem.hh`) containing the initial and boundary conditions.
template<class TypeTag>
struct Problem<TypeTag, TTag::ChannelExampleMomentum>
{ using type = Dumux::ChannelExampleProblem<TypeTag, Dumux::NavierStokesMomentumProblem<TypeTag>> ; };
template<class TypeTag>
struct Problem<TypeTag, TTag::ChannelExampleMass>
{ using type = Dumux::ChannelExampleProblem<TypeTag, Dumux::NavierStokesMassProblem<TypeTag>> ; };

// This sets the fluid system type to be used. Here, we use a liquid with constant properties as the fluid phase.
template<class TypeTag>
struct FluidSystem<TypeTag, TTag::ChannelExample>
{
    using Scalar = GetPropType<TypeTag, Properties::Scalar>;
    using type = FluidSystems::OnePLiquid<Scalar, Components::Constant<1, Scalar> >;
};
```

We also set some properties related to memory management
throughout the simulation.
<details><summary> Click to show caching properties</summary>

In DuMu<sup>x</sup>, one has the option to activate/deactivate the grid-wide caching of
geometries and variables. If active, the CPU time can be significantly reduced
as less dynamic memory allocation procedures are necessary. Per default, grid-wide
caching is disabled to ensure minimal memory requirements, however, in this example we
want to active all available caches, which significantly increases the memory
demand but makes the simulation faster.


```cpp
// This enables grid-wide caching of the volume variables.
template<class TypeTag>
struct EnableGridVolumeVariablesCache<TypeTag, TTag::ChannelExample> { static constexpr bool value = true; };
//This enables grid wide caching for the flux variables.
template<class TypeTag>
struct EnableGridFluxVariablesCache<TypeTag, TTag::ChannelExample> { static constexpr bool value = true; };
// This enables grid-wide caching for the finite volume grid geometry
template<class TypeTag>
struct EnableGridGeometryCache<TypeTag, TTag::ChannelExample> { static constexpr bool value = true; };
```

</details>
Finally we define the coupling manager to couple the momentum and mass subproblems

```cpp
template<class TypeTag>
struct CouplingManager<TypeTag, TTag::ChannelExample>
{
    using Traits = MultiDomainTraits<TTag::ChannelExampleMomentum, TTag::ChannelExampleMass>;
    using type = FreeFlowCouplingManager<Traits>;
};
} // end namespace Dumux::Properties
```


</details>



## Initial and boundary conditions (`problem.hh`)

This file contains the __problem class__ which defines the initial and boundary
conditions for the Navier-Stokes single-phase flow simulation.


<details open>
<summary><b>Click to hide/show the file documentation</b> (or inspect the [source code](problem.hh))</summary>


### Include files

Include the `NavierStokesBoundaryTypes` class which specifies the boundary types set in this problem.

```cpp
#include <dumux/freeflow/navierstokes/boundarytypes.hh>
```


Include helper functions to compute values for boundary conditions

```cpp
#include <dumux/freeflow/navierstokes/momentum/fluxhelper.hh>
#include <dumux/freeflow/navierstokes/scalarfluxhelper.hh>
#include <dumux/freeflow/navierstokes/mass/1p/advectiveflux.hh>
```

### The problem class
We enter the problem class `ChannelExampleProblem` where all necessary boundary conditions and initial conditions are set for our simulation.
As we are solving a problem related to free flow using a coupled model, we inherit from the base
class of the respective subproblem for momentum or mass balance (see `properties.hh`).

```cpp
namespace Dumux {

template <class TypeTag, class BaseProblem>
class ChannelExampleProblem : public BaseProblem
{
    // A few convenience aliases used throughout this class.
    using ParentType = BaseProblem;
    using GridGeometry = GetPropType<TypeTag, Properties::GridGeometry>;
    using FVElementGeometry = typename GridGeometry::LocalView;
    using SubControlVolumeFace = typename GridGeometry::SubControlVolumeFace;
    using ModelTraits = GetPropType<TypeTag, Properties::ModelTraits>;
    using Indices = typename ModelTraits::Indices;
    using BoundaryTypes = typename ParentType::BoundaryTypes;
    using InitialValues = typename ParentType::InitialValues;
    using Sources = typename ParentType::Sources;
    using DirichletValues = typename ParentType::DirichletValues;
    using BoundaryFluxes = typename ParentType::BoundaryFluxes;
    using Scalar = GetPropType<TypeTag, Properties::Scalar>;

    using Element = typename GridGeometry::GridView::template Codim<0>::Entity;
    using GlobalPosition = typename Element::Geometry::GlobalCoordinate;
    using CouplingManager = GetPropType<TypeTag, Properties::CouplingManager>;

public:
    // This is the constructor of our problem class:
    // Within the constructor, we set the inlet velocity to a run-time specified value.
    // If no run-time value is specified, we set the outlet pressure to 1.1e5 Pa.
    ChannelExampleProblem(std::shared_ptr<const GridGeometry> gridGeometry,
                          std::shared_ptr<CouplingManager> couplingManager)
    : ParentType(gridGeometry, couplingManager)
    {
        inletVelocity_ = getParam<Scalar>("Problem.InletVelocity");
        outletPressure_ = getParam<Scalar>("Problem.OutletPressure", 1.1e5);
    }
```

#### Boundary conditions
With the following function we define the __type of boundary conditions__ depending on the location.
Two types of boundary conditions can be specified: Dirichlet or Neumann. On
Dirichlet boundaries, the values of the primary variables need to be fixed. On Neumann boundaries,
the flux needs to be fixed.
To set different conditions for the two subproblems, use `constexpr ParentType::isMomentumProblem()`
to distinguish between momentum and mass problem.
To set Dirichlet conditions for the pressure, we have to specify a solution-dependent Neumann
condition for the momentum balance, which depends on the pressure.
This condition can be obtained using the helper function `fixedPressureMomentumFlux`.

```cpp
    BoundaryTypes boundaryTypesAtPos(const GlobalPosition& globalPos) const
    {
        BoundaryTypes values;

        if constexpr(ParentType::isMomentumProblem())
        {
            // We specify Dirichlet boundary conditions for the velocity on most boundaries of our domain
            values.setDirichlet(Indices::velocityXIdx);
            values.setDirichlet(Indices::velocityYIdx);

            if (isOutlet_(globalPos))
            {
                // We fix the pressure on the right side of the domain, for the momentum balance we compute the resulting flux
                values.setAllNeumann();
            }
        }
        else
        {
            if (isInlet_(globalPos))
            {
                // We specify Dirichlet boundary conditions for the velocity on the left of our
                // domain, the corresponding pressure can be obtained from the coupling manager
                values.setDirichlet(Indices::pressureIdx);
            }
            else if (isOutlet_(globalPos))
            {
                // We fix the pressure on the right side of the domain through the momentum outflow,
                // for the mass balance we may prescribe a pressure or a mass outflow computed from velocity fields
                values.setNeumann(Indices::conti0EqIdx);
            }
            else
            {
                // We specify no-flow Neumann boundary conditions for the mass balance on the remaining boundaries (lower and upper wall)
                // in addition to the Dirichlet boundary conditions for the velocity (momentum balance)
                values.setAllNeumann();
            }
        }

        return values;
    }
```

The following function specifies the __fluxes on Neumann boundaries__.
We need to define fluxes for the balance equations (momentum or mass).

```cpp
    template<class ElementVolumeVariables, class ElementFluxVariablesCache>
    BoundaryFluxes neumann(const Element& element,
                           const FVElementGeometry& fvGeometry,
                           const ElementVolumeVariables& elemVolVars,
                           const ElementFluxVariablesCache& elemFluxVarsCache,
                           const SubControlVolumeFace& scvf) const
    {
        // No flow as default
        BoundaryFluxes values(0.0);

        if constexpr (ParentType::isMomentumProblem())
        {
            // Compute the solution-dependent momentum flux for the specified pressure and zero normal velocity gradient
            using FluxHelper = NavierStokesMomentumBoundaryFlux<typename GridGeometry::DiscretizationMethod>;
            values = FluxHelper::fixedPressureMomentumFlux(*this, fvGeometry, scvf, elemVolVars, elemFluxVarsCache, outletPressure_, true /*zeroNormalVelocityGradient*/);
        }
        else
        {
            // Compute the solution-dependent mass flux based on velocity fields
            using FluxHelper = NavierStokesScalarBoundaryFluxHelper<AdvectiveFlux<ModelTraits>>;
            if (isOutlet_(scvf.ipGlobal()))
                values = FluxHelper::scalarOutflowFlux(*this, element, fvGeometry, scvf, elemVolVars);
        }

        return values;
    }
```

The following function specifies the __values on Dirichlet boundaries__.
We need to define values for the primary variables (velocity or pressure).

```cpp
    DirichletValues dirichlet(const Element& element, const SubControlVolumeFace& scvf) const
    {
        const auto& globalPos = scvf.ipGlobal();
        // Use the initial values as default Dirichlet values
        DirichletValues values = initialAtPos(globalPos);

        if constexpr (ParentType::isMomentumProblem())
        {
            // Set a no-slip condition at the top and bottom wall of the channel
            if (!isInlet_(globalPos))
                values[Indices::velocityXIdx] = 0.0;
        }
        else
        {
            if (isInlet_(globalPos))
                values = this->couplingManager().cellPressure(element, scvf);
        }

        return values;
    }
```

The following function defines the initial conditions.

```cpp
    InitialValues initialAtPos(const GlobalPosition& globalPos) const
    {
        InitialValues values;

        // Set the pressure and velocity values
        if constexpr (ParentType::isMomentumProblem())
        {
            values[Indices::velocityXIdx] = inletVelocity_;
            values[Indices::velocityYIdx] = 0.0;
        }
        else
        {
            //std::cout << "setting outlet pressure at " << globalPos << std::endl;
            values[Indices::pressureIdx] = outletPressure_;
        }

        return values;
    }
```

In order to reduce numeric inaccuracies caused by large differences in magnitude
between pressure and velocity gradient, we introduce a reference pressure,
which is subtracted from the pressure in the computation of the momentum flux.

```cpp
    Scalar referencePressure(const Element& element,
                             const FVElementGeometry& fvGeometry,
                             const SubControlVolumeFace& scvf) const
    {
        return 110000.0;
    }
```

The inlet is on the left side of the physical domain.

```cpp
private:
    bool isInlet_(const GlobalPosition& globalPos) const
    { return globalPos[0] < eps_; }
```

The outlet is on the right side of the physical domain.

```cpp
    bool isOutlet_(const GlobalPosition& globalPos) const
    { return globalPos[0] > this->gridGeometry().bBoxMax()[0] - eps_; }
```

Finally, private variables are declared:

```cpp
    static constexpr Scalar eps_ = 1e-6;
    Scalar inletVelocity_;
    Scalar outletPressure_;

}; // end class definition of ChannelExampleProblem
} // end namespace Dumux
```


</details>



## The main file (`main.cc`)

<details open>
<summary><b>Click to hide/show the file documentation</b> (or inspect the [source code](main.cc))</summary>


### Included header files
<details><summary> Click to show includes</summary>
These are DUNE helper classes related to parallel computations and file I/O.

```cpp
#include <dune/common/parallel/mpihelper.hh>
#include <dune/grid/io/file/dgfparser/dgfexception.hh>
```

The following headers include functionality related to property definition or retrieval, as well as
the retrieval of input parameters specified in the input file or via the command line.

```cpp
#include <dumux/common/properties.hh>
#include <dumux/common/parameters.hh>
#include <dumux/common/initialize.hh>
```

The following files contain the non-linear Newton solver for multi-domain problems, the available linear solver backends and the assembler for the linear
systems arising from the staggered-grid discretization.

```cpp
#include <dumux/multidomain/newtonsolver.hh>
#include <dumux/linear/istlsolvers.hh>
#include <dumux/linear/linearalgebratraits.hh>
#include <dumux/linear/linearsolvertraits.hh>
#include <dumux/multidomain/fvassembler.hh>
#include <dumux/multidomain/traits.hh>
#include <dumux/assembly/diffmethod.hh> // analytic or numeric differentiation
```

The following class provides a convenient way of writing of dumux simulation results to VTK format and `velocityoutput.hh` allows to additionally write out velocity data of the staggered grid.

```cpp
#include <dumux/io/vtkoutputmodule.hh>
#include <dumux/freeflow/navierstokes/momentum/velocityoutput.hh>
```

The gridmanager constructs a grid from the information in the input or grid file.
Many different Dune grid implementations are supported, of which a list can be found
in `gridmanager.hh`.

```cpp
#include <dumux/io/grid/gridmanager.hh>
```

This class contains functionality for additional flux output.

```cpp
#include <dumux/freeflow/navierstokes/fluxoveraxisalignedsurface.hh>
```

This class contains functionality to account for extruded domains.

```cpp
#include <dumux/discretization/extrusion.hh>
```

In this header three `TypeTag`s are defined, which collect
the properties that are required for the simulation.
It also contains the actual problem with initial and boundary conditions.
For detailed information, please have a look
at the documentation provided therein.

```cpp
#include "properties.hh"
```

</details>

### The main function
We will now discuss the main program flow implemented within the `main` function.
At the beginning of each program using Dune, an instance of `Dune::MPIHelper` has to
be created. Moreover, we parse the run-time arguments from the command line and the
input file:

```cpp
int main(int argc, char** argv) try
{
    using namespace Dumux;

    // maybe initialize MPI and/or multithreading backend
    Dumux::initialize(argc, argv);
    const auto& mpiHelper = Dune::MPIHelper::instance();

    // parse command line arguments and input file
    Parameters::init(argc, argv);
```

We define convenience aliases for the type tags of the subproblems. The type
tags contain all the properties that are needed to define the model and the problem
setup. Throughout the main file, we will obtain types defined for these type tags
using the property system, i.e. with `GetPropType`. Shared properties can be obtained through
either of them.

```cpp
    using MomentumTypeTag = Properties::TTag::ChannelExampleMomentum;
    using MassTypeTag = Properties::TTag::ChannelExampleMass;
```

#### Step 1: Create the grid
The `GridManager` class creates the grid from information given in the input file.
This can either be a grid file, or in the case of structured grids, one can specify the coordinates
of the corners of the grid and the number of cells to be used to discretize each spatial direction.
'Grid` is a property that is shared by both type tags (see `properties.hh`).
As stated above, it can therefore be obtained through either `MassTypeTag` of `MomentumTypeTag`.

```cpp
    GridManager<GetPropType<MomentumTypeTag, Properties::Grid>> gridManager;
    gridManager.init();

    // We compute on the leaf grid view.
    const auto& leafGridView = gridManager.grid().leafGridView();
```

#### Step 2: Setting up and solving the problem
First, a finite volume grid geometry is constructed from the grid that was created above.
This builds the sub-control volumes (`scv`) and sub-control volume faces (`scvf`) for each element
of the grid partition.
This is done separately for the momentum and mass grid geometries.

```cpp
    using MomentumGridGeometry = GetPropType<MomentumTypeTag, Properties::GridGeometry>;
    auto momentumGridGeometry = std::make_shared<MomentumGridGeometry>(leafGridView);
    using MassGridGeometry = GetPropType<MassTypeTag, Properties::GridGeometry>;
    auto massGridGeometry = std::make_shared<MassGridGeometry>(leafGridView);
```

We introduce the multidomain coupling manager, which will couple the two subproblems for mass
and momentum. The type can be obtained using either of the two type tags.

```cpp
    using CouplingManager = GetPropType<MomentumTypeTag, Properties::CouplingManager>;
    auto couplingManager = std::make_shared<CouplingManager>();
```

We now instantiate the problems, in which we define the boundary and initial conditions.

```cpp
    using MassProblem = GetPropType<MassTypeTag, Properties::Problem>;
    auto massProblem = std::make_shared<MassProblem>(massGridGeometry, couplingManager);
    using MomentumProblem = GetPropType<MomentumTypeTag, Properties::Problem>;
    auto momentumProblem = std::make_shared<MomentumProblem>(momentumGridGeometry, couplingManager);
```

We set a solution vector `x` which consist of two parts: one part (indexed by `massIdx`)
is for the pressure degrees of freedom (`dofs`) living in grid cell centers. Another part
(indexed by `momentumIdx`) is for degrees of freedom defining the normal velocities on grid cell faces.
The relevant types can be accessed through the `MultiDomainTraits` of the coupled problem.
We initialize the solution vector by what was defined as the initial solution of the problem.

```cpp
    using Traits = MultiDomainTraits<MomentumTypeTag, MassTypeTag>;
    using SolutionVector = typename Traits::SolutionVector;
    constexpr auto momentumIdx = CouplingManager::freeFlowMomentumIndex;
    constexpr auto massIdx = CouplingManager::freeFlowMassIndex;
    SolutionVector x;
    momentumProblem->applyInitialSolution(x[momentumIdx]);
    massProblem->applyInitialSolution(x[massIdx]);
```

The grid variables are used to store variables (primary and secondary variables) of the two subproblems.

```cpp
    using MomentumGridVariables = GetPropType<MomentumTypeTag, Properties::GridVariables>;
    auto momentumGridVariables = std::make_shared<MomentumGridVariables>(momentumProblem, momentumGridGeometry);
    using MassGridVariables = GetPropType<MassTypeTag, Properties::GridVariables>;
    auto massGridVariables = std::make_shared<MassGridVariables>(massProblem, massGridGeometry);
```

After initializing the coupling manager the coupling context is set up and the grid variables
of the subproblems can be initialized.

```cpp
    couplingManager->init(momentumProblem, massProblem, std::make_tuple(momentumGridVariables, massGridVariables), x);
    momentumGridVariables->init(x[momentumIdx]);
    massGridVariables->init(x[massIdx]);
```

We then initialize the predefined model-specific VTK output.

```cpp
    using IOFields = GetPropType<MassTypeTag, Properties::IOFields>;
    VtkOutputModule vtkWriter(*massGridVariables, x[massIdx], massProblem->name());
    IOFields::initOutputModule(vtkWriter); // Add model specific output fields
    vtkWriter.addVelocityOutput(std::make_shared<NavierStokesVelocityOutput<MassGridVariables>>());
    vtkWriter.write(0.0);
```

We create and initialize the `assembler` for the stationary problem.
This is where the Jacobian matrix for the Newton solver is assembled.

```cpp
    using Assembler = MultiDomainFVAssembler<Traits, CouplingManager, DiffMethod::numeric>;
    auto assembler = std::make_shared<Assembler>(std::make_tuple(momentumProblem, massProblem),
                                                 std::make_tuple(momentumGridGeometry, massGridGeometry),
                                                 std::make_tuple(momentumGridVariables, massGridVariables),
                                                 couplingManager);
```

We use UMFPack as direct linear solver within each Newton iteration.

```cpp
    using LinearSolver = Dumux::UMFPackIstlSolver<SeqLinearSolverTraits, LinearAlgebraTraitsFromAssembler<Assembler>>;
    auto linearSolver = std::make_shared<LinearSolver>();
```

This example considers a linear problem (incompressible Stokes flow), therefore
the non-linear Newton solver is not really necessary.
For sake of generality, we nevertheless use it here such that the example can be easily
changed to a non-linear problem by switching on the inertia terms in the input file or by choosing a compressible fluid.
In the following piece of code we instantiate the non-linear newton solver and let it solve
the problem.

```cpp
    // alias for and instantiation of the newton solver
    using NewtonSolver = Dumux::MultiDomainNewtonSolver<Assembler, LinearSolver, CouplingManager>;
    NewtonSolver nonLinearSolver(assembler, linearSolver, couplingManager);
```

<details><summary> Click to show calculation of surface fluxes</summary>

We set up two surfaces over which fluxes are calculated.
We determine the extent $`[xMin,xMax] \times [yMin,yMax]`$ of the physical domain.
The first surface (added by the first call of `addAxisAlignedSurface`) shall be placed at the middle of the channel.
The second surface (second call of `addAxisAlignedSurface`) is placed at the outlet of the channel.

```cpp
    FluxOverAxisAlignedSurface flux(*massGridVariables, x[massIdx], assembler->localResidual(massIdx));

    using Scalar = typename Traits::Scalar;

    const Scalar xMin = massGridGeometry->bBoxMin()[0];
    const Scalar xMax = massGridGeometry->bBoxMax()[0];
    const Scalar yMin = massGridGeometry->bBoxMin()[1];
    const Scalar yMax = massGridGeometry->bBoxMax()[1];

    const Scalar planePosMiddleX = xMin + 0.5*(xMax - xMin);

    using GridView = typename MassGridGeometry::GridView;
    using Element = typename GridView::template Codim<0>::Entity;
    using GlobalPosition = typename Element::Geometry::GlobalCoordinate;

    const auto p0middle = GlobalPosition{planePosMiddleX, yMin};
    const auto p1middle = GlobalPosition{planePosMiddleX, yMax};
    flux.addAxisAlignedSurface("middle", p0middle, p1middle);

    const auto p0outlet = GlobalPosition{xMax, yMin};
    const auto p1outlet = GlobalPosition{xMax, yMax};
    flux.addAxisAlignedSurface("outlet", p0outlet, p1outlet);

    using FluxVariables = GetPropType<MassTypeTag, Properties::FluxVariables>;
    using Extrusion = Extrusion_t<MassGridGeometry>;
    auto volumeFlux = [&](const auto& element,
                         const auto& fvGeometry,
                         const auto& elemVolVars,
                         const auto& scvf,
                         const auto& elemFluxVarsCache)
    {
        if (scvf.boundary() && massProblem->boundaryTypes(element, scvf).hasNeumann())
            return massProblem->neumann(element, fvGeometry, elemVolVars, elemFluxVarsCache, scvf)[0]
                    * Extrusion::area(fvGeometry, scvf) * elemVolVars[scvf.insideScvIdx()].density();
        else
        {
            FluxVariables fluxVars;
            fluxVars.init(*massProblem, element, fvGeometry, elemVolVars, scvf, elemFluxVarsCache);
            return fluxVars.getAdvectiveFlux([](const auto& volVars) { return 1.0; });
        }
    };
```

</details>

Solve the (potentially non-linear) system.

```cpp
    nonLinearSolver.solve(x);
```

In the following we calculate and print mass and volume fluxes over the planes specified above
(you have to click to unfold the code showing how to set up the surface fluxes above).

```cpp
    flux.calculateAllFluxes();
    if (GetPropType<MassTypeTag, Properties::ModelTraits>::enableEnergyBalance())
    {
        std::cout << "mass / energy flux at middle is: " << flux.flux("middle") << std::endl;
        std::cout << "mass / energy flux at outlet is: " << flux.flux("outlet") << std::endl;
    }
    else
    {
        std::cout << "mass flux at middle is: " << flux.flux("middle") << std::endl;
        std::cout << "mass flux at outlet is: " << flux.flux("outlet") << std::endl;
    }

    flux.calculateFluxes(volumeFlux);
    std::cout << "volume flux at middle is: " << flux.flux("middle")[0] << std::endl;
    std::cout << "volume flux at outlet is: " << flux.flux("outlet")[0] << std::endl;
```

#### Final Output
We write the VTK output and conclude by printing the dumux end message.

```cpp
    vtkWriter.write(1.0);

    if (mpiHelper.rank() == 0)
        Parameters::print();

    return 0;
} // end main
```

#### Exception handling
In this part of the main file we catch and print possible exceptions that could
occur during the simulation.
<details><summary> Click to show exception handler</summary>

```cpp
// errors related to run-time parameters
catch (Dumux::ParameterException &e)
{
    std::cerr << std::endl << e << " ---> Abort!" << std::endl;
    return 1;
}
// errors related to the parsing of Dune grid files
catch (Dune::DGFException & e)
{
    std::cerr << "DGF exception thrown (" << e <<
                 "). Most likely, the DGF file name is wrong "
                 "or the DGF file is corrupted, "
                 "e.g. missing hash at end of file or wrong number (dimensions) of entries."
                 << " ---> Abort!" << std::endl;
    return 2;
}
// generic error handling with Dune::Exception
catch (Dune::Exception &e)
{
    std::cerr << "Dune reported error: " << e << " ---> Abort!" << std::endl;
    return 3;
}
// other exceptions
catch (...)
{
    std::cerr << "Unknown exception thrown! ---> Abort!" << std::endl;
    return 4;
}
```

</details>

</details>

