<!-- Important: This file has been automatically generated by generate_example_docs.py. Do not edit this file directly! -->


| [:arrow_left: Back to the main documentation](../README.md) | [:arrow_right: Continue with part 2](postprocessing.md) |
|---|---:|

# Part 1: Implementation

The implementation of simulation setup and main flow is structured as follows:

[[_TOC_]]


## Compile-time settings (`properties.hh`)

In this file, the type tag used for this simulation is defined,
for which we then specialize properties (compile time options) to the needs of the desired setup.


<details open>
<summary><b>Click to hide/show the file documentation</b> (or inspect the [source code](../properties.hh))</summary>


### Includes
<details><summary> Click to show includes</summary>

The single-phase flow Navier-Stokes equations are solved by coupling a momentum balance model to a mass balance model.

```cpp
#include <dumux/freeflow/navierstokes/momentum/fcstaggered/model.hh>
#include <dumux/freeflow/navierstokes/mass/1p/model.hh>
#include <dumux/freeflow/navierstokes/momentum/problem.hh>
#include <dumux/freeflow/navierstokes/mass/problem.hh>
#include <dumux/multidomain/traits.hh>
#include <dumux/multidomain/freeflow/couplingmanager.hh>
```

We want to use `YaspGrid`, an implementation of the dune grid interface for structured grids:

```cpp
#include <dune/grid/yaspgrid.hh>
```

In this example, we want to discretize the momentum and mass balance equations with the staggered-grid
scheme which is so far the only available option for free-flow models in DuMux. Velocities are defined on the
element edges while pressures are defined on the element centers.

```cpp
#include <dumux/discretization/fcstaggered.hh>
#include <dumux/discretization/cctpfa.hh>
```

The fluid properties are specified in the following headers (we use a liquid with constant properties as the fluid phase):

```cpp
#include <dumux/material/components/constant.hh>
#include <dumux/material/fluidsystems/1pliquid.hh>
```

We include the problem header used for this simulation.

```cpp
#include "problem.hh"
```

</details>

### Type tag definition

We define a type tag for our simulation with the name `LidDrivenCavityExample`. As we are dealing with a coupled model,
we also define type tags for the momentum and mass model and inherit from the respective physical models (`NavierStokesMomentum` and `NavierStokesMassOneP`)
as well as from the appropriate spatial discretization schemes (`FaceCenteredStaggeredModel` and `CCTpfaModel`).

```cpp

namespace Dumux::Properties {

namespace TTag {
struct LidDrivenCavityExample {};
struct LidDrivenCavityExampleMomentum { using InheritsFrom = std::tuple<LidDrivenCavityExample, NavierStokesMomentum, FaceCenteredStaggeredModel>; };
struct LidDrivenCavityExampleMass { using InheritsFrom = std::tuple<LidDrivenCavityExample, NavierStokesMassOneP, CCTpfaModel>; };
} // end namespace TTag
```

### Property specializations

In the following piece of code, mandatory properties for which no meaningful
default exist are specialized for our type tag `LidDrivenCavityExample`.

```cpp
// This sets the fluid system to be used. Here, we use a liquid with constant properties as fluid phase.
template<class TypeTag>
struct FluidSystem<TypeTag, TTag::LidDrivenCavityExample>
{
    using Scalar = GetPropType<TypeTag, Properties::Scalar>;
    using type = FluidSystems::OnePLiquid<Scalar, Components::Constant<1, Scalar> >;
};
// This sets the grid type used for the simulation. Here, we use a structured 2D grid.
template<class TypeTag>
struct Grid<TypeTag, TTag::LidDrivenCavityExample> { using type = Dune::YaspGrid<2>; };

// This sets our problem class (see problem.hh) containing initial and boundary conditions for the
// momentum and mass subproblem.
template<class TypeTag>
struct Problem<TypeTag, TTag::LidDrivenCavityExampleMomentum>
{ using type = LidDrivenCavityExampleProblem<TypeTag, Dumux::NavierStokesMomentumProblem<TypeTag>>; };

template<class TypeTag>
struct Problem<TypeTag, TTag::LidDrivenCavityExampleMass>
{ using type = LidDrivenCavityExampleProblem<TypeTag, Dumux::NavierStokesMassProblem<TypeTag>>; };
```

We also set some properties related to memory management
throughout the simulation.
<details><summary> Click to show caching properties</summary>

In DuMux, one has the option to activate/deactivate the grid-wide caching of
geometries and variables. If active, the CPU time can be significantly reduced
as less dynamic memory allocation procedures are necessary. Per default, grid-wide
caching is disabled to ensure minimal memory requirements, however, in this example we
want to active all available caches, which significantly increases the memory
demand but makes the simulation faster.


```cpp
// This enables grid-wide caching of the volume variables.
template<class TypeTag>
struct EnableGridGeometryCache<TypeTag, TTag::LidDrivenCavityExample> { static constexpr bool value = true; };
//This enables grid wide caching for the flux variables.
template<class TypeTag>
struct EnableGridFluxVariablesCache<TypeTag, TTag::LidDrivenCavityExample> { static constexpr bool value = true; };
// This enables grid-wide caching for the finite volume grid geometry
template<class TypeTag>
struct EnableGridVolumeVariablesCache<TypeTag, TTag::LidDrivenCavityExample> { static constexpr bool value = true; };
```

</details>
Finally, we introduce the coupling manager to the properties system
We do this at the end so that all specialized properties are defined

```cpp
template<class TypeTag>
struct CouplingManager<TypeTag, TTag::LidDrivenCavityExample>
{
    using Traits = MultiDomainTraits<TTag::LidDrivenCavityExampleMomentum, TTag::LidDrivenCavityExampleMass>;
    using type = FreeFlowCouplingManager<Traits>;
};
} // end namespace Dumux::Properties
```


</details>



## Initial and boundary conditions (`problem.hh`)

This file contains the __problem class__ which defines the initial and boundary
conditions for the Navier-Stokes single-phase flow simulation.


<details open>
<summary><b>Click to hide/show the file documentation</b> (or inspect the [source code](../problem.hh))</summary>


### Include files


```cpp
#include <dumux/common/properties.hh>
#include <dumux/common/parameters.hh>
```

Include the `NavierStokesBoundaryTypes` class which specifies the boundary types set in this problem.

```cpp
#include <dumux/freeflow/navierstokes/boundarytypes.hh>
```

### The problem class
As we are solving a problem related to free flow, we create a new class called `LidDrivenCavityExampleProblem`
and let it inherit from a base class for the momentum and mass subproblems (selected in `properties.hh`).

```cpp
namespace Dumux {
template <class TypeTag, class BaseProblem>
class LidDrivenCavityExampleProblem : public BaseProblem
{
    using ParentType = BaseProblem;

    using BoundaryTypes = typename ParentType::BoundaryTypes;
    using GridGeometry = GetPropType<TypeTag, Properties::GridGeometry>;
    using FVElementGeometry = typename GridGeometry::LocalView;
    using SubControlVolume = typename GridGeometry::SubControlVolume;
    using SubControlVolumeFace = typename GridGeometry::SubControlVolumeFace;
    using Indices = typename GetPropType<TypeTag, Properties::ModelTraits>::Indices;
    using InitialValues = typename ParentType::InitialValues;
    using Sources = typename ParentType::Sources;
    using DirichletValues = typename ParentType::DirichletValues;
    using BoundaryFluxes = typename ParentType::BoundaryFluxes;
    using Scalar = GetPropType<TypeTag, Properties::Scalar>;

    static constexpr auto dimWorld = GridGeometry::GridView::dimensionworld;
    using Element = typename FVElementGeometry::Element;
    using GlobalPosition = typename Element::Geometry::GlobalCoordinate;
    using CouplingManager = GetPropType<TypeTag, Properties::CouplingManager>;

public:
    // Within the constructor, we set the lid velocity to a run-time specified value.
    LidDrivenCavityExampleProblem(std::shared_ptr<const GridGeometry> gridGeometry, std::shared_ptr<CouplingManager> couplingManager)
    : ParentType(gridGeometry, couplingManager)
    {
        lidVelocity_ = getParam<Scalar>("Problem.LidVelocity");
    }
```

#### Boundary conditions
With the following function we define the __type of boundary conditions__ depending on the location.
Three types of boundary conditions can be specified: Dirichlet or Neumann boundary conditions. On
Dirichlet boundaries, the values of the primary variables need to be fixed. On a Neumann boundaries,
values for derivatives need to be fixed.

```cpp
    BoundaryTypes boundaryTypesAtPos(const GlobalPosition &globalPos) const
    {
        BoundaryTypes values;

        // We set Dirichlet values for the velocity at each boundary. At the same time,
        // Neumann (no-flow) conditions hold at the boundaries for the mass model.
        if constexpr (ParentType::isMomentumProblem())
            values.setAllDirichlet();
        else
            values.setAllNeumann();

        return values;
    }
```

The following function specifies the __values on Dirichlet boundaries__.
We need to define values for the primary variables (velocity).

```cpp
    DirichletValues dirichletAtPos(const GlobalPosition &globalPos) const
    {
        DirichletValues values(0.0);

        if constexpr (ParentType::isMomentumProblem())
        {
            if (globalPos[1] > this->gridGeometry().bBoxMax()[1] - eps_)
                values[Indices::velocityXIdx] = lidVelocity_;
        }

        return values;
    }
```

The following function specifies the __values on Neumann boundaries__.
We define a (zero) mass flux here.

```cpp
    template<class ElementVolumeVariables, class ElementFluxVariablesCache>
    BoundaryFluxes neumann(const Element& element,
                           const FVElementGeometry& fvGeometry,
                           const ElementVolumeVariables& elemVolVars,
                           const ElementFluxVariablesCache& elemFluxVarsCache,
                           const SubControlVolumeFace& scvf) const
    {
        BoundaryFluxes values(0.0);

        if constexpr (!ParentType::isMomentumProblem())
        {
            // Density is constant, so inside or outside does not matter.
            const auto insideDensity = elemVolVars[scvf.insideScvIdx()].density();

            // The resulting flux over the boundary is zero anyway (velocity is zero), but this will add some non-zero derivatives to the
            // Jacobian and makes the BC more general.
            values[Indices::conti0EqIdx] = this->faceVelocity(element, fvGeometry, scvf) * insideDensity * scvf.unitOuterNormal();
        }

        return values;
    }
```

The problem setup considers closed boundaries everywhere. In order to have a defined pressure level, we impose an __internal Dirichlet
constraint for pressure__ in a single cell.

```cpp

    // Use internal Dirichlet constraints for the mass problem.
    static constexpr bool enableInternalDirichletConstraints()
    { return !ParentType::isMomentumProblem(); }

    // Set a fixed pressure a the lower-left cell.
    std::bitset<DirichletValues::dimension> hasInternalDirichletConstraint(const Element& element, const SubControlVolume& scv) const
    {
        std::bitset<DirichletValues::dimension> values;

        if constexpr (!ParentType::isMomentumProblem())
        {
            const bool isLowerLeftCell = (scv.dofIndex() == 0);
            if (isLowerLeftCell)
                values.set(0);
        }

        return values;
    }

    // Specify the pressure value in the internal Dirichlet cell.
    DirichletValues internalDirichlet(const Element& element, const SubControlVolume& scv) const
    { return DirichletValues(1.1e5); }
```

Setting a __reference pressure__ can help to improve the Newton convergence rate by making the numerical derivatives more exact.
This is related to floating point arithmetic as pressure values are usually much higher than velocities.

```cpp
    Scalar referencePressure(const Element& element,
                             const FVElementGeometry& fvGeometry,
                             const SubControlVolumeFace& scvf) const
    { return 1.0e5; }
```

The following function defines the initial conditions.

```cpp
    InitialValues initialAtPos(const GlobalPosition &globalPos) const
    {
        InitialValues values(0.0);

        if constexpr (!ParentType::isMomentumProblem())
            values[Indices::pressureIdx] = 1.0e+5;

        return values;
    }
```

Finally, the (private) data members of the problem class.

```cpp
private:
    static constexpr Scalar eps_ = 1e-6;
    Scalar lidVelocity_;
};

} // end namespace Dumux
```


</details>



## The main file (`main.cc`)

<details open>
<summary><b>Click to hide/show the file documentation</b> (or inspect the [source code](../main.cc))</summary>


### Included header files
<details><summary> Click to show includes</summary>
These is DUNE helper class related to parallel computation

```cpp
#include <dune/common/parallel/mpihelper.hh>
```

The following headers include functionality related to property definition or retrieval, as well as
the retrieval of input parameters specified in the input file or via the command line.

```cpp
#include <dumux/common/parameters.hh>
#include <dumux/common/properties.hh>
#include <dumux/common/initialize.hh>
```

The following files contain the multi-domain Newton solver, the available linear solver backends and the assembler for the linear
systems arising from the staggered-grid discretization.

```cpp
#include <dumux/linear/istlsolvers.hh>
#include <dumux/linear/linearalgebratraits.hh>
#include <dumux/linear/linearsolvertraits.hh>
#include <dumux/multidomain/fvassembler.hh>
#include <dumux/multidomain/traits.hh>
#include <dumux/multidomain/newtonsolver.hh>
```

The gridmanager constructs a grid from the information in the input or grid file.
Many different Dune grid implementations are supported, of which a list can be found
in `gridmanager.hh`.

```cpp
#include <dumux/io/grid/gridmanager_yasp.hh>
```

This class contains functionality for VTK output for models using the staggered finite volume scheme.

```cpp
#include <dumux/io/vtkoutputmodule.hh>
#include <dumux/freeflow/navierstokes/momentum/velocityoutput.hh>
```

We include the problem header used for this simulation.

```cpp
#include "properties.hh"
```

</details>
The following function writes the velocities and coordinates at x = 0.5 and y = 0.5 into a log file.

```cpp
template<class Problem, class SolutionVector>
void writeSteadyVelocityAndCoordinates(const Problem& problem, const SolutionVector& sol)
{
    const auto& gridGeometry = problem.gridGeometry();
    std::ofstream logFilevx(problem.name() + "_vx.log"), logFilevy(problem.name() + "_vy.log");
    logFilevx << "y vx\n";
    logFilevy << "x vy\n";

    static constexpr double eps_ = 1.0e-7;
    std::vector<int> dofHandled(gridGeometry.numDofs(), false);
    for (const auto& element : elements(gridGeometry.gridView()))
    {
        auto fvGeometry = localView(gridGeometry);
        fvGeometry.bind(element);
        for (const auto& scv : scvs(fvGeometry))
        {
            if (dofHandled[scv.dofIndex()])
                continue;

            if (!scv.boundary())
            {
                const auto& globalPos = scv.dofPosition();
                const auto velocity = sol[scv.dofIndex()][0];
                dofHandled[scv.dofIndex()] = true;

                if (std::abs(globalPos[0]-0.5) < eps_)
                    logFilevx << globalPos[1] << " " << velocity << "\n";
                else if (std::abs(globalPos[1]-0.5) < eps_)
                    logFilevy << globalPos[0] << " " << velocity << "\n";
            }
        }
    }
}
```

### The main function
We will now discuss the main program flow implemented within the `main` function.
At the beginning of each program using Dune, an instance of `Dune::MPIHelper` has to
be created. Moreover, we parse the run-time arguments from the command line and the
input file:

```cpp
int main(int argc, char** argv)
{
    using namespace Dumux;

    // maybe initialize MPI and/or multithreading backend
    Dumux::initialize(argc, argv);
    const auto& mpiHelper = Dune::MPIHelper::instance();

    // parse command line arguments and input file
    Parameters::init(argc, argv);
```

We define a convenience alias for the type tags of the problems. The type
tag contains all the properties that are needed to define the model and the problem
setup. Throughout the main file, we will obtain types defined each type tag
using the property system, i.e. with `GetPropType`.

```cpp
    using MomentumTypeTag = Properties::TTag::LidDrivenCavityExampleMomentum;
    using MassTypeTag = Properties::TTag::LidDrivenCavityExampleMass;
```

#### Step 1: Create the grid
The `GridManager` class creates the grid from information given in the input file.
This can either be a grid file, or in the case of structured grids, one can specify the coordinates
of the corners of the grid and the number of cells to be used to discretize each spatial direction.

```cpp
    GridManager<GetPropType<MomentumTypeTag, Properties::Grid>> gridManager;
    gridManager.init();

    // We compute on the leaf grid view.
    const auto& leafGridView = gridManager.grid().leafGridView();
```

#### Step 2: Setting up and solving the problem
First, a finite volume grid geometry is constructed from the grid that was created above.
This builds the sub-control volumes (scv) and sub-control volume faces (scvf) for each element
of the grid partition.
This is done for both the momentum and mass grid geometries

```cpp
    using MomentumGridGeometry = GetPropType<MomentumTypeTag, Properties::GridGeometry>;
    auto momentumGridGeometry = std::make_shared<MomentumGridGeometry>(leafGridView);
    using MassGridGeometry = GetPropType<MassTypeTag, Properties::GridGeometry>;
    auto massGridGeometry = std::make_shared<MassGridGeometry>(leafGridView);
```

We introduce the multidomain coupling manager, which will couple the mass and the momentum problems
We can obtain the type from either the `MomentumTypeTag` or the `MassTypeTag` because they are mutually coupled with the same manager

```cpp
    using CouplingManager = GetPropType<MomentumTypeTag, Properties::CouplingManager>;
    auto couplingManager = std::make_shared<CouplingManager>();
```

We now instantiate the problems, in which we define the boundary and initial conditions.

```cpp
    using MomentumProblem = GetPropType<MomentumTypeTag, Properties::Problem>;
    auto momentumProblem = std::make_shared<MomentumProblem>(momentumGridGeometry, couplingManager);
    using MassProblem = GetPropType<MassTypeTag, Properties::Problem>;
    auto massProblem = std::make_shared<MassProblem>(massGridGeometry, couplingManager);
```

We set a solution vector which consist of two parts: one part (indexed by `massIdx`)
is for the pressure degrees of freedom (`dofs`) living in grid cell centers. Another part
(indexed by `momentumIdx`) is for degrees of freedom defining the normal velocities on grid cell faces.
We initialize the solution vector by what was defined as the initial solution of the the problem.

```cpp
    constexpr auto momentumIdx = CouplingManager::freeFlowMomentumIndex;
    constexpr auto massIdx = CouplingManager::freeFlowMassIndex;
    using Traits = MultiDomainTraits<MomentumTypeTag, MassTypeTag>;
    using SolutionVector = typename Traits::SolutionVector;
    SolutionVector x;
    momentumProblem->applyInitialSolution(x[momentumIdx]);
    massProblem->applyInitialSolution(x[massIdx]);
    auto xOld = x;
```

We use the initial solution vector to create the `gridVariables`.
The grid variables are used store variables (primary and secondary variables) on sub-control volumes and faces (volume and flux variables).

```cpp
    using MomentumGridVariables = GetPropType<MomentumTypeTag, Properties::GridVariables>;
    auto momentumGridVariables = std::make_shared<MomentumGridVariables>(momentumProblem, momentumGridGeometry);
    using MassGridVariables = GetPropType<MassTypeTag, Properties::GridVariables>;
    auto massGridVariables = std::make_shared<MassGridVariables>(massProblem, massGridGeometry);
```

using the problems and the grid variables, the coupling manager and the grid variables are initialized with the initial solution.
The grid variables have to be initialized _after_ the coupling manager.
This is because they require the correct coupling context between the mass and momentum model to be initialized.

```cpp
    couplingManager->init(momentumProblem, massProblem, std::make_tuple(momentumGridVariables, massGridVariables), x, xOld);
    momentumGridVariables->init(x[momentumIdx]);
    massGridVariables->init(x[massIdx]);
```

We get some time loop parameters from the input file
and instantiate the time loop

```cpp
    using Scalar = typename Traits::Scalar;
    const auto tEnd = getParam<Scalar>("TimeLoop.TEnd");
    const auto maxDt = getParam<Scalar>("TimeLoop.MaxTimeStepSize");
    const auto dt = getParam<Scalar>("TimeLoop.DtInitial");

    auto timeLoop = std::make_shared<TimeLoop<Scalar>>(0, dt, tEnd);
    timeLoop->setMaxTimeStepSize(maxDt);
```

We then initialize the predefined model-specific output vtk output.

```cpp
    using IOFields = GetPropType<MassTypeTag, Properties::IOFields>;
    VtkOutputModule vtkWriter(*massGridVariables, x[massIdx], massProblem->name());
    IOFields::initOutputModule(vtkWriter); // Add model specific output fields
    vtkWriter.addVelocityOutput(std::make_shared<NavierStokesVelocityOutput<MassGridVariables>>());
    vtkWriter.write(0.0);
```

To solve the non-linear problem at hand, we use the `NewtonSolver`,
which we have to tell how to assemble and solve the system in each
iteration. Here, we use the direct linear solver UMFPack.

```cpp
    using Assembler = MultiDomainFVAssembler<Traits, CouplingManager, DiffMethod::numeric>;
    auto assembler = std::make_shared<Assembler>(std::make_tuple(momentumProblem, massProblem),
                                                 std::make_tuple(momentumGridGeometry, massGridGeometry),
                                                 std::make_tuple(momentumGridVariables, massGridVariables),
                                                 couplingManager, timeLoop, xOld);
```

the linear solver

```cpp
    using LinearSolver = Dumux::UMFPackIstlSolver<SeqLinearSolverTraits, LinearAlgebraTraitsFromAssembler<Assembler>>;
    auto linearSolver = std::make_shared<LinearSolver>();
```

the non-linear solver

```cpp
    using NewtonSolver = MultiDomainNewtonSolver<Assembler, LinearSolver, CouplingManager>;
    NewtonSolver nonLinearSolver(assembler, linearSolver, couplingManager);
```

##### The time loop
In each time step, we solve the non-linear system of equations, write
the current solution into VTK files and prepare for the next time step.

```cpp
    timeLoop->start(); do
    {
        // We solve the non-linear system with time step control.
        nonLinearSolver.solve(x, *timeLoop);

        // We make the new solution the old solution.
        xOld = x;
        massGridVariables->advanceTimeStep();
        momentumGridVariables->advanceTimeStep();

        // We advance to the time loop to the next step.
        timeLoop->advanceTimeStep();

        // We write vtk output for each time step.
        vtkWriter.write(timeLoop->time());

        // We report statistics of this time step.
        timeLoop->reportTimeStep();

        // We set a new dt as suggested by the newton solver for the next time step.
        timeLoop->setTimeStepSize(nonLinearSolver.suggestTimeStepSize(timeLoop->timeStepSize()));

    } while (!timeLoop->finished());
```

We write the velocities and coordinates at x = 0.5 and y = 0.5 into a file.

```cpp
    writeSteadyVelocityAndCoordinates(*momentumProblem, x[momentumIdx]);
```

The following piece of code prints a final status report of the time loop
before the program is terminated.

```cpp
    timeLoop->finalize(leafGridView.comm());

    // print used and unused parameters
    if (mpiHelper.rank() == 0)
        Parameters::print();

    return 0;
} // end main
```


</details>


| [:arrow_left: Back to the main documentation](../README.md) | [:arrow_right: Continue with part 2](postprocessing.md) |
|---|---:|

