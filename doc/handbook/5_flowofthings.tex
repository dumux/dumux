\section{The flow of things in \Dumux}
\label{flow}

\todo[inline]{I think here we can delete some portion of text}

This chapter is supposed to show how things are ``handed around'' in \Dumux. This
is not a comprehenisve guide through the modeling framework of \Dumux, but
hopefully it will help getting to grips with it.

In Section \ref{content} the structure of \Dumux is shown from a \emph{content}
point of view.
Section \ref{implementation} is written from the point of view of the \emph{implementation}.
These two approaches are linked by the circled numbers (like \textbf{\textcircled{\ref{init}}})
in the flowchart of Section \ref{implementation} corresponding to the enumeration
of the list of Section \ref{content}. This is supposed to demonstrate at which point
of the program-flow you are content- and implementation-wise.

Section \ref{implementation} is structured by \fbox{boxes} and
$\overrightarrow{\textnormal{arrows}}$. Boxes stand for more or less important
points in the programm. They may may be reckoned ``step stones''. Likewise, the
arrows connect the boxes. If important things happen in between, it is written
under the arrows.

\fbox{Plain boxes} stand for generic parts of the program. \fbox{\fbox{double}}
$\lbrace\lbrace$boundings$\rbrace\rbrace$ stand for the implementation specific
part of the program, like \verb+2p, 2p2c...+. This will be the most important
part for most users. \uwave{snakelike lines} tell you that this part is specific
to the components considered.

For keeping things simple, the program flow of a \verb+2p+ model is shown.
There are extensive comments regarding the formating in the tex file: so feel free,
to enhance this description.

\subsection{Structure -- by Content}
\label{content}
% by means of this enumerated list, the connection between algorithm and content
% can be achieved by references to the labels of this list.
This list shows the algorithmic outline of a typical \Dumux run. Each item stands
for a characteristic step within the modeling framework.

\clearpage
In Figure \ref{fig:algorithm}, the algorithmic representations of both approaches
down to the element level are illustrated.

\begin{figure}[hbt]
\begin{tabular}{ l | l }

\begin{minipage}[t]{0.48\textwidth}
\setcounter{thingCounter}{0}

\scriptsize
\sffamily
\begin{tabbing}
\textbf{{\begin{turn}{45}\numberThis{main}{init}\end{turn}}} 			 \=
\textbf{{\begin{turn}{45}\numberThis{time step}{prep}\end{turn}}} 			 \=
\textbf{{\begin{turn}{45}\numberThis{\textsc{Newton}}{elem}\end{turn}}} 		\=
\textbf{{\begin{turn}{45}\numberThis{element}{calc}\end{turn}}} 			\=  \\
\\
initialize \\
\textbf{foreach} time step\\

  \> prepare update\\
  \> \textbf{foreach} \textsc{Newton} iteration \\

    \> \> \textbf{foreach} element \\

      \> \> \> - calculate element \\
      \>\>\>  \; residual vector and \\
      \>\>\>  \; Jacobian matrix\\
      \> \> \> - assemble into global\\
      \>\>\>  \; residual vector and \\
      \> \> \>  \;{Jacobian} matrix \\

    \> \> \textbf{endfor} \\

    \> \> solve linear system\\
    \> \> update solution\\
    \> \> check for \textsc{Newton} convergence\\
  \> \textbf{endfor}\\
  \> - adapt time step size, \\
  \> \; possibly redo with smaller step size\\
  \> - write result\\
\textbf{endfor}\\
finalize
\end{tabbing}

\end{minipage}

&

\begin{minipage}[t]{0.48\textwidth}
\setcounter{thingCounter}{0}

\scriptsize
\sffamily
\begin{tabbing}
\textbf{{\begin{turn}{45}1. main\end{turn}}} 			 \=
\textbf{{\begin{turn}{45}2. time step\end{turn}}} 			 \=
\textbf{{\begin{turn}{45}3. \textsc{IMPES/C}\end{turn}}} 		\=
\textbf{{\begin{turn}{45}4. element\end{turn}}} 			\=  \\
\\
initialize \\
\textbf{foreach} time step\\

  \> prepare update\\
  \> \textbf{foreach} \textsc{IMPES/C} step \\
    \> \> \textbf{if} grid is adaptive\\
      \> \> \> - calculate refinement indicator\\
      \> \> \> - mark elements, adapt the grid\\
      \> \> \> - map old solution to new grid\\
    \> \> - calculate {flow field}\\
    \> \>  \textbf{foreach} element \\

      \> \> \> - calculate element stiffness matrix \\
      \> \> \> - assemble into global matrix \\

    \> \>  \textbf{endfor} \\
    \> \>  solve linear system\\

    \> \> - calculate {transport} \\
    \> \> \; (saturations, concentrations,...) \\
    \> \>   \textbf{foreach} element  \\
      \> \> \> -calculate update (explicitly) \\
      \> \> \>- adapt time step ({CFL}-like criterion) \\
    \> \>   \textbf{endfor} \\
    \> \> - update old solution \\
    \> \> - postprocess (flash calculation, etc.)\\
  \> \textbf{endfor}\\
\> - write result\\
\textbf{endfor}\\
finalize
\end{tabbing}

\end{minipage}
\end{tabular}

\caption{Structure of a coupled fully-implicit (\textbf{left}) and a decoupled
semi-implicit (\textbf{right}) scheme in \Dumux.}
\label{fig:algorithm}
\end{figure}

\subsubsection{Levels}

\textcircled{\ref{init}} main\\
\textcircled{\ref{prep}} time step\\
\textcircled{\ref{elem}} \textsc{Newton} step\\
\textcircled{\ref{calc}} Element-wise assembly

\subsection{Structure --  by Implementation}
 \label{implementation}
This section is supposed to help you in getting an idea how things are handled in
\Dumux and in which files things are written down.
This is not intuitivly clear, therefore it is mentioned for each \fbox{step-stone}.
\textbf{called by} tells you from which file a function is
accessed. \textbf{implemented in} tells you in which file the function is written
down. The name of the function is set in \verb+typewriter+.
Being a function is indicated by round brackets \verb+()+ but only the function
name is given and not the full signature (arguments...) .
 Comments regarding the events within one step-stone are set \scriptsize{smaller}.



\begin{landscape}
%switch off headings and footer in order to get more space for the flowchart
\pagestyle{empty}
{\small
\setlength{\voffset}{4.2cm}
%%README!!! it is important NOT to leave any blank lines, as multiple boxes are supposed to be in one line
%% Unfortunately, blank lines need to be inserted manually if one box is lapping over the page border
%% by means of \newline, a new line plus some extra space can be inserted, which has unfortunately to be done after each line
%% \newline is defined at the beginning of this file
%% sometimes \texttt{} is used (in stead of \verb), as it is not possible to have ANY environment within \verb.
%% If multiple lines are supposed to be under one arrow, I used an align environment and switched back to \textnormal for each line
%% a blank template for one step-stone is at the end of the file

%%SAMPLE:
%    \begin{tabular}{|l|} % each box is a single table, left jusified and bars to the right and left
%       \hline % this makes the top bar of the box
%       \textbf{\textcircled{\ref{calc}}}\verb+ctl.newtonEnd()+ \\ % this is the line for showing code. also in this line the circled numbers are printed, that show the connection to the content wise structure. The numbers are realized as references to the enumerated list. bold!
%       \begin{scriptsize}\end{scriptsize}\\
%       \textbf{called by}:\\ %one line in the box/ table: ``called by'' is set in bold face
%       \textbf{implemented in}: \\ %another line in the box / table
% 	\hline % this line is smaller textsize for writing comments \hline makesthe bottom bar of the box
%   \end{tabular}
%     $\overrightarrow{\scriptsize % this is the arrow connecting two boxes. In can carry text.
%     \begin{array}{l} % if the arrow is supposed to carry multiple lines, an array is inserted.
%     \textnormal{timemanager.hh}\\ % formating within an array is tiring. Each line needs its own set of size and textnormal
%     \textbf{\textcircled{\ref{prep}}} \rightarrow \textbf{\textcircled{\ref{init}}}
%     \end{array}
%     }$
  \begin{tabular}{|l|} \hline
    \textbf{\textcircled{\ref{init}}}\verb+start()+ \\
    \begin{scriptsize}start the simulation\end{scriptsize}\\
    \textbf{called by}: main() \\
    \textbf{implemented in}: start.hh \\
    \hline
  \end{tabular}
    $\overrightarrow{}$
  \begin{tabular}{|l|} \hline
    \textbf{\textcircled{\ref{init}}}\verb+timeManager.init()+ \\
    \begin{scriptsize}initialization\end{scriptsize}\\
    \textbf{called by}: start() \\
    \textbf{implemented in}: timemanager.hh \\
    \hline
  \end{tabular}
    $\overrightarrow{}$
  \begin{tabular}{|l|}\hline
    \textbf{\textcircled{\ref{init}}}\verb+timeManager.run()+\\
    \begin{scriptsize}\end{scriptsize}\\
    \textbf{called by}: {start()}\\
    \textbf{implemented in}: {timemanager.hh}\\
    \hline
  \end{tabular}
{\scriptsize
    $\overrightarrow{ %an arrow under which things may be written
      \begin{array}{l} % in order to be able to write multiple lines under the arrow
	\textnormal{\texttt{while(!finished)}}\\
	\textbf{\textbf{\textcircled{\ref{init}}}} \rightarrow \textbf{\textcircled{\ref{prep}} }
      \end{array}
    }$}
  \begin{tabular}{|l|}
    \hline
    \textbf{\textcircled{\ref{prep}}}\verb+problem->timeIntegration()+ \\
    \begin{scriptsize}execute time integration scheme \end{scriptsize}\\
    \textbf{called by}: timemanager.hh\\
    \textbf{implemented in}: implicitproblem.hh\\
\hline
  \end{tabular}
\nextline
    {\scriptsize$\overrightarrow{
      \begin{array}{l}
	\textnormal{define number of allowed \textsc{Newton} fails} \\
	\textnormal{(each halving dt)}
      \end{array}
    }$}
      \begin{tabular}{|l|}
    \hline
    \textbf{\textcircled{\ref{prep}}}\verb+model->update()+ \\
    \begin{scriptsize}sth like numerical model\end{scriptsize}\\
    \textbf{called by}: implicitproblem.hh\\
    \textbf{implemented in}: implicitmodel.hh\\
	\hline
  \end{tabular}
    {\scriptsize$\overrightarrow{ }$}
% %     $\overrightarrow{}$
% %     \begin{tabular}{|l|}
% %       \hline
% %      \textbf{\textcircled{\ref{prep}}}\verb+asImp_().updatebegin()+ \\
% %     \begin{scriptsize}\textbf{applies Dirichlets}\end{scriptsize}\\
% %     \begin{scriptsize}\textbf{not applied here any mroe}\end{scriptsize}\\
% %       \textbf{called by}: boxscheme.hh\\
% %       \textbf{implemented in}: boxscheme.hh\\
% % 	\hline
% %   \end{tabular}
% %
%    % {\scriptsize$\overrightarrow{
%       %\begin{array}{l}
% % 	\textnormal{\texttt{while(true)}loop} \\
% % 	\rightarrow \textnormal{until converged}
% %       \end{array} } $}
% %
    \begin{tabular}{|l|}
      \hline
            \textbf{\textcircled{\ref{prep}}}\verb+solver.execute()+ \\
            \begin{scriptsize}$\begin{array}{l}
      \textnormal{not only solving in there: applying \textsc{Newton} method} \\
      \rightsquigarrow\textnormal{solver keeps track of things}\\
      \textnormal{catching errors}
      \end{array}$\end{scriptsize}\\
      \textbf{called by}: implicitmodel.hh\\
      \textbf{implemented in}: newtonmethod.hh : $\texttt{execute\_()}$\\
    \hline
  \end{tabular}
\nextline
 $\overrightarrow{ \begin{array}{l}
				  \textbf{\textcircled{\ref{prep}}} \rightarrow \textbf{\textcircled{\ref{elem}}}\\
                                  \texttt{while(ctl.newtonProceed())}\\
				  \textnormal{uLastIter = uCurrentIter(model.uCur())}
                                 \end{array}
    }$
    \begin{tabular}{|l|}
      \hline
	\textbf{\textcircled{\ref{elem}}}\verb+jacobianAsm.assemble()+ \\
    \begin{scriptsize}linearize the problem:  \end{scriptsize}\\
    \begin{scriptsize}add all element contributions to global \textsc{Jacobian} and global residual\end{scriptsize}\\
      \textbf{called by}: newtonmethod.hh\\
      \textbf{implemented in}: implicitassembler.hh\\
	\hline
  \end{tabular}
    \nextline
    $\overrightarrow{
    }$
    \begin{tabular}{|l|}
      \hline
	\textbf{\textcircled{\ref{elem}}}\verb+resetSystem_()+ \\
    \begin{scriptsize} set r.h.s. (i.e. residual) and\end{scriptsize}\\
    \begin{scriptsize} set \textsc{Jacobian} to zero \end{scriptsize}\\
      \textbf{called by}: implicitassembler.hh\\
      \textbf{implemented in}: implicitassembler.hh\\
	\hline
  \end{tabular}
    {\scriptsize$\overrightarrow{\begin{array}{l}
				  \textbf{\textcircled{\ref{elem}}}\rightarrow\textbf{\textcircled{\ref{calc}}}\\
				  \texttt{loop all elements}
                                \end{array}
    }$}
     \begin{tabular}{|l|}
      \hline
      \textbf{\textcircled{\ref{calc}}}\verb+assembleElement_()+ \\
      \begin{scriptsize}call local \textsc{Jacobian} and residual assembly\end{scriptsize}\\
      \textbf{called by}: implicitassembler.hh\\
      \textbf{implemented in}: implicitassembler.hh\\
      \hline
     \end{tabular}
\nextline
    {\scriptsize$\overrightarrow{
        }$}
     \begin{tabular}{|l|}
      \hline
     \textbf{\textcircled{\ref{calc}}}\verb+model_().localJacobian().assemble()+ \\
     \begin{scriptsize}set curr. element, update element's fin.vol.geom.\end{scriptsize}\\
     \begin{scriptsize}reset local \textsc{Jacobian} to 0\end{scriptsize}\\
     \begin{scriptsize}update types of boundaries on this element\end{scriptsize}\\
      \textbf{called by}: implicitassembler.hh\\
      \textbf{implemented in}:  implicitlocaljacobian.hh\\
	\hline
  \end{tabular}
    $\overrightarrow{
    }$
    \begin{tabular}{|l|}
      \hline
      \textbf{\textcircled{\ref{calc}}}\verb+prevVolVars_.update()+, \textbf{\textcircled{\ref{calc}}}\verb+curVolVars_.update()+ \\
    \begin{scriptsize}call model specific update of quantities defined for the volume:\end{scriptsize}\\
    \begin{scriptsize}variables for the \emph{current and previous timestep...!!}\end{scriptsize}\\
      \textbf{called by}: implicitlocaljacobian.hh\\
      \textbf{implemented in}: implicitelementvolumevariables.hh\\
	\hline
  \end{tabular}
\nextline
    $\overrightarrow{
    }$
    \begin{tabular}{||l||}
      \hline\hline
      \textbf{\textcircled{\ref{calc}}}\verb+update()+ \\
    \begin{scriptsize}calculate all two-phase specific quantites defined in the volume\end{scriptsize}\\
      \textbf{called by}: boxelementvolumevariables.hh\\
      \textbf{implemented in}: 2pvolumevariables.hh\\
	\hline\hline
  \end{tabular}
    $\overrightarrow{
    }$
      \begin{tabular}{||l||}
\hline\hline
      \textbf{\textcircled{\ref{calc}}}\verb+completeFluidState()+ \\
      \begin{scriptsize}calculate all required fluid properties from the primary variables\end{scriptsize}\\
      \textbf{called by}: 2pvolumevariables.hh\\
      \textbf{implemented in}: 2pvolumevariables.hh\\
\hline\hline
      \end{tabular}
\nextline
    $\overrightarrow{
    }$
      \begin{tabular}{||l||}
\uwave{\mbox{\phantom{\textbf{\textcircled{\ref{calc}}}+ e.g: density\_ = Fluidsystem::phaseDensity()+ bissl}}}
\\
      \textbf{\textcircled{\ref{calc}}}\verb+ e.g: rho = Fluidsystem::density()+ \\
      \verb+ fluidState.setDensity(phaseIdx,rho)+ \\
      \begin{scriptsize}The fluid system does the real work: \end{scriptsize}\\
      \begin{scriptsize}calculates densities, diffusivities ... \end{scriptsize}\\
      \begin{scriptsize}The fluidstate save and provides them. \end{scriptsize}\\
      \textbf{called by}: 2pvolumevariables.hh\\
      \textbf{implemented in}: 2pvolumevariables.hh\\
\uwave{\mbox{\phantom{\textbf{\textcircled{\ref{calc}}}+ e.g: density\_ = Fluidsystem::phaseDensity()+ bissl}}}
\\
      \end{tabular}
    $\overrightarrow{
    }$
    \begin{tabular}{|l|}
      \hline
    \textbf{\textcircled{\ref{calc}}}\verb+localResidual().eval()+ \\
    \begin{scriptsize}the element's local residual is calculated:\end{scriptsize}\\
    \begin{scriptsize}see the next two stepstones\end{scriptsize}\\
      \textbf{called by}: implicitlocaljacobian.hh\\
      \textbf{implemented in}: boxlocalresidual.hh\\
     \hline
  \end{tabular}
    $\overrightarrow{
    }$
    \begin{tabular}{|l|}
      \hline
    \textbf{\textcircled{\ref{calc}}}\verb+asImp_().evalFluxes_()+ \\
    \begin{scriptsize}evaluate the fluxes going into each finite volume\end{scriptsize}\\
    \begin{scriptsize}how this is done is \fbox{\fbox{model specific}} (see below)\end{scriptsize}\\
      \textbf{called by}: boxlocalresidual.hh\\
      \textbf{implemented in}: boxlocalresidual.hh\\
     \hline
  \end{tabular}
\nextline
{$\overrightarrow{}$}
     \begin{tabular}{||l||}
        \hline\hline
        \textbf{\textcircled{\ref{calc}}}\verb+computeFluxes()+ \\
        \begin{scriptsize}model specific flux computation  \end{scriptsize}\\
        \textbf{called by}: boxlocalresidual.hh\\
        \textbf{implemented in}: 2plocalresidual.hh\\
        \hline\hline
     \end{tabular}
    $\overrightarrow{
    }$
     \begin{tabular}{||l||}
        \hline\hline
        \textbf{\textcircled{\ref{calc}}}\verb+FluxVariables fluxVars()+ \\
        \begin{scriptsize}this is a call to a constructor:  \end{scriptsize}\\
        \begin{scriptsize}calculate the velocities \end{scriptsize}\\
        \textbf{called by}: 2plocalresidual.hh\\
        \textbf{implemented in}: boxdarcyfluxvariables.hh\\
        \hline\hline
     \end{tabular}
    $\overrightarrow{
    }$
     \begin{tabular}{||l||}
      \hline\hline
      	\textbf{\textcircled{\ref{calc}}}\verb+computeAdvectiveFlux()+ (other models: also diffusive)\\
    	\scriptsize{upwinding decision via  \verb+massUpwindWeight_+}\\
	\textbf{called by}: 2plocalresidual.hh\\
      	\textbf{implemented in}: 2plocalresidual.hh\\
     \hline\hline
  \end{tabular}
\nextline
    $\overrightarrow{
    }$
    \begin{tabular}{|l|}
      \hline
    \textbf{\textcircled{\ref{calc}}}\verb+asImp_().evalVolumeTerms_()+ \\
    \begin{scriptsize}evaluate the storage and source terms for each finite volume\end{scriptsize}\\
    \begin{scriptsize}how this is done is \fbox{\fbox{model specific}} (see below)\end{scriptsize}\\
      \textbf{called by}: boxlocalresidual.hh\\
      \textbf{implemented in}: boxlocalresidual.hh\\
     \hline
  \end{tabular}
    $\overrightarrow{
    }$
    \begin{tabular}{|l|}
      \hline
    \textbf{\textcircled{\ref{calc}}}\verb+asImp_().evalBoundary_()+ \\
    \begin{scriptsize}deal with the boundary conditions\end{scriptsize}\\
    \begin{scriptsize}may be \fbox{\fbox{model specific}}\end{scriptsize}\\
      \textbf{called by}: boxlocalresidual.hh\\
      \textbf{implemented in}: boxlocalresidual.hh (or modelspecific)\\
     \hline
  \end{tabular}
    $\overrightarrow{
    }$
    \begin{tabular}{|l|}
      \hline
    \textbf{\textcircled{\ref{calc}}}\verb+asImp_().evalPartialDerivative()+ \\
    \begin{scriptsize}actually calculate the element's (local) \textsc{Jacobian} matrix\end{scriptsize}\\
    \begin{scriptsize}a property chooses backward/central/foward differences\end{scriptsize}\\
    \begin{scriptsize}here: central differences\end{scriptsize}\\
      \textbf{called by}: implicitlocaljacobian.hh\\
      \textbf{implemented in}: implicitlocaljacobian.hh\\
     \hline
  \end{tabular}
\nextline
    $\overrightarrow{
    }$
    \begin{minipage}{0.50\textwidth}
  \begin{scriptsize}\textnormal{approximation of partial derivatives: numerical differentiation}\end{scriptsize}\\
  \begin{scriptsize}\textnormal{add $\pm \epsilon$ solution, divide difference of residual by $2\epsilon$}\end{scriptsize}\\
  \begin{scriptsize}\textnormal{all partial derivatives for the element from the local \textsc{Jacobian} matrix}\end{scriptsize}\\
$\left \lbrace
     \begin{tabular}{l}%these question marks are for the \verb, not meant as ``unclear''
     	\verb?priVars[pvIdx]+=eps?\\
        \begin{scriptsize}\textnormal{this is adding eps to the current solution}\end{scriptsize}\\
	\verb?curVolVars_[scvIdx].update(+eps)?\\
        \begin{scriptsize}\textnormal{recalculate volume variables, having $\epsilon$ added}\end{scriptsize}\\
     	\verb?localResidual().eval(+eps)?\\
        \begin{scriptsize}\textnormal{calculate local residual for modified solution as before: involves}\end{scriptsize}\\
	{\scriptsize $\begin{array}{l}
		\textnormal{- \textbf{computeFlux}}\\
		\textnormal{- \textbf{computeStorage}}\\
		\textnormal{- \textbf{computeSource}} \\
	\end{array}$} \\
     \verb?store the residual()?\\
     \verb?repeat for priVars[pvIdx]-=eps?\\
     \verb?derivative is (residual(+eps) - residual(-eps))/2eps?\\
  \end{tabular}
  \right .
 $
    \end{minipage}
\hspace{.25\textwidth}
  {\scriptsize$\overrightarrow{}$ }
   \begin{tabular}{|l|}
      \hline
      \textbf{\textcircled{\ref{calc}}}\verb+assembleElement_()+ \\
      \verb+model_().localJacobian().assemble()+ \\
      \begin{scriptsize}Residual of the current solution is now\end{scriptsize}\\
      \begin{scriptsize}``numerically differentiated'', for the element i.e.\end{scriptsize}\\
      \begin{scriptsize}the local \textsc{Jacobian} matrix is calculated. \end{scriptsize}\\
      \textbf{called by}: implicitassembler.hh \\
      \textbf{implemented in}: implicitassembler.hh\\
	\hline
  \end{tabular}
  {\scriptsize$\overrightarrow{}$ }
  $\left|
     \begin{array}{l}
    \textnormal{The contribution of a single element is done.}\\
    \textnormal{Now, it needs to be added to the global quantities:}\\
    \textnormal{Add to global residual and global \textsc{Jacobian}.}
  \end{array}
  \right |$
    {\scriptsize$\overrightarrow{}$ }
   \begin{tabular}{|l|}
      \hline
      \textbf{\textcircled{\ref{calc}}}\verb?resdidual_[globI]+=? \\
		  \verb?    model_().globalJacobian().resdidual(i)? \\
      \begin{scriptsize}Add to global residual.\end{scriptsize}\\
      \textbf{called by}: continuing in the function. \\
      \textbf{implemented in}: implicitassembler.hh\\
	\hline
  \end{tabular}
 \nextline
   {\scriptsize$\overrightarrow{
    \begin{array}{l}
    \textnormal{loop vertices}\\
    \textnormal{of an element}
    \end{array}}$}
   \begin{tabular}{|l|}
      \hline
      \textbf{\textcircled{\ref{calc}}}\verb?(*matrix_)[globI][globJ] +=? \\
		\verb?    model_().localJacobian().mat(i,j)? \\
      \begin{scriptsize}Add to global \textsc{Jacobian}.\end{scriptsize}\\
      \textbf{called by}: continuing in the function. \\
      \textbf{implemented in}: implicitassembler.hh\\
	\hline
  \end{tabular}
    {\scriptsize$\overrightarrow{
	  \begin{array}{l}
	   \textbf{\textcircled{\ref{calc}}}\rightarrow\textbf{\textcircled{\ref{elem}}}\\
           \end{array}
    }$}
   \begin{tabular}{|l|}
      \hline
      \textbf{\textcircled{\ref{elem}}}\verb?assemble()? \\
      \begin{scriptsize}Assembling of elements to global quantities is done.\end{scriptsize}\\
      %\begin{scriptsize}In case: print partial assembling stuff\end{scriptsize}\\
      \textbf{called by}: continuing in the function. \\
      \textbf{implemented in}: implicitassembler.hh\\
	\hline
  \end{tabular}
\nextline
    {$\overrightarrow{}
    $}
   \begin{tabular}{|l|}
      \hline
      \textbf{\textcircled{\ref{elem}}}\verb?while newtonProceed()  ?\\
      \begin{scriptsize}Print information.\end{scriptsize}\\
      \begin{scriptsize}start/ stop timer.\end{scriptsize}\\
      \textbf{called by}: continuing in the function, $\texttt{execute\_()}$ \\
      \textbf{implemented in}: newtonmethod.hh\\
	\hline
  \end{tabular}
    {\scriptsize$\overrightarrow
				  {\begin{array}{l}
				  \textnormal{set delta Vector to zero} \\
				  \textnormal{(this is what is}\\
				  \textnormal{solved for later)}\\
                                \end{array}}
    $}
   \begin{tabular}{|l|}
      \hline
      \textbf{\textcircled{\ref{elem}}}\verb?newtonSolveLinear()  ?\\
      \begin{scriptsize}Ask the linear solver to solve the system.\end{scriptsize}\\
      \begin{scriptsize}i.e. : give \textsc{Jacobian}(matrix), delta(x), r.h.s.(residual) to linear solver\end{scriptsize}\\
      \begin{scriptsize}$\nabla r(x^k) \cdot \Delta x^k = r(x^k)$\end{scriptsize}\\
      \begin{scriptsize}tricky: each \textsc{Newton}step solves a linear system of equations. \end{scriptsize}\\
      \textbf{called by}: continuing in the function, $\texttt{execute\_()}$. \\
      \textbf{implemented in}: newtonmethod.hh\\
	\hline
  \end{tabular}
\nextline
    {\scriptsize$\overrightarrow{}
    $}
   \begin{tabular}{|l|}
      \hline
      \textbf{\textcircled{\ref{elem}}}\verb+newtonSolveLinear()+\\
      \begin{scriptsize}Catching errors.\end{scriptsize}\\
      \textbf{called by}: newtonmethod.hh\\
      \textbf{implemented in}: newtoncontroller.hh\\
	\hline
  \end{tabular}
    {\scriptsize$\overrightarrow{}
    $}
   \begin{tabular}{|l|}
      \hline
      \textbf{\textcircled{\ref{elem}}}\verb+linearSolver_.solve()+\\
      \begin{scriptsize}Solve the linear system with the chosen backend.\end{scriptsize}\\
      \textbf{called by}: newtoncontroller.hh\\
      \textbf{implemented in}: boxlinearsolver.hh\\
	\hline
  \end{tabular}
\nextline
    {\scriptsize$\overrightarrow{}
    $}
   \begin{tabular}{|l|}
      \hline
      \textbf{\textcircled{\ref{elem}}}\verb+ctl.newtonUpdate()+\\
      \begin{scriptsize}We solved for  the change in solution, but need the solution:\end{scriptsize}\\
      \begin{scriptsize}Calculate current (this iteration) solution\end{scriptsize}\\
      \begin{scriptsize}\quad from last (iteration) solution and current (iteration) change in  solution:\end{scriptsize}\\
      \begin{scriptsize} $x^{k+1} = x^k - \Delta x^k$ where $\Delta x^k = (\nabla r(x^k))^{-1} \cdot r(x^k)$\end{scriptsize}\\
      \textbf{called by}: newtonmethod.hh\\
      \textbf{implemented in}: newtoncontroller.hh\\
        \hline
  \end{tabular}
    {\scriptsize$\overrightarrow{}
    $}
   \begin{tabular}{|l|}
      \hline
      \textbf{\textcircled{\ref{elem}}}\verb+newtonupdateRelError()+\\
      \begin{scriptsize}calculate the \emph{relative error} between two iterations\end{scriptsize}\\
      \begin{scriptsize}\quad find the prim. var. that changed most between \end{scriptsize}\\
      \begin{scriptsize}\quad last(\verb+uLastIter+) and current (\verb+uCurrentIter+) \end{scriptsize}\\
      \begin{scriptsize}\quad \textsc{Newton} iteration.\end{scriptsize}\\
      \textbf{called by}: newtoncontroller.hh\\
      \textbf{implemented in}: newtoncontroller.hh\\
	\hline
  \end{tabular}
\nextline
    {\scriptsize$\overrightarrow{}
    $}
   \begin{tabular}{|l|}
      \hline
      \textbf{\textcircled{\ref{elem}}}\verb+ctl.newtonEndStep()+\\
      \begin{scriptsize}Increase counter for number of \textsc{Newton} steps. \end{scriptsize}\\
      \begin{scriptsize}Print info. \end{scriptsize}\\
      \textbf{called by}: newtonmethod.hh\\
      \textbf{implemented in}: newtoncontroller.hh\\
	\hline
  \end{tabular}
    {\scriptsize$\overrightarrow
				  {\begin{array}{l}
				  \textnormal{check whether to do another \textsc{Newton} iteration:}\\
				  \textnormal{that is: check if the error is below tolerance or}\\
                                  \textnormal{maximum number of iterations was reached.}\\
                                \end{array}}
    $}
    {\scriptsize$\overrightarrow{\begin{array}{l}
				  \textbf{\textcircled{\ref{elem}}}\rightarrow\textbf{\textcircled{\ref{prep}}}\\
				  \textnormal{\textsc{Newton} done.}\\
				  \textnormal{if failed $\rightsquigarrow$ halve timestep size, restart loop}
                                \end{array}
    }$}
\nextline
    \begin{tabular}{|l|}
      \hline
      \textbf{\textcircled{\ref{prep}}}\verb+ctl.newtonEnd()+ \\
      \begin{scriptsize}Tell the controller we are done\end{scriptsize}\\
      \textbf{called by}: newtonmethod.hh\\
      \textbf{implemented in}: newtoncontroller.hh\\
      \hline
    \end{tabular}
    {\scriptsize$\overrightarrow{ }$}
    \begin{tabular}{|l|}
      \hline
      \textbf{\textcircled{\ref{prep}}}\verb+asImp_().updateSuccessful()+ \\
      \begin{scriptsize}Can be filled by the \fbox{\fbox{model}}.\end{scriptsize}\\
      \textbf{called by}: implicitmodel.hh\\
      \textbf{implemented in}: implicitmodel.hh\\
	\hline
    \end{tabular}
    {\scriptsize$\overrightarrow
				  {\begin{array}{l}
				  \textnormal{in while(!finished)}\\
                                \end{array}}
    $}
    \begin{tabular}{|l|}
      \hline
      \textbf{\textcircled{\ref{prep}}}\verb+problem_.postTimeStep(),writeOutput()+ \\
      \begin{scriptsize}Give the \fbox{\fbox{problem}} the chance to\end{scriptsize}\\
      \begin{scriptsize}post-process the solution.\end{scriptsize}\\
      \textbf{called by}: timemanager.hh\\
      \textbf{implemented in}: implicitproblem.hh\\
	\hline
    \end{tabular}
\nextline
    {\scriptsize$\overrightarrow
                                  {\begin{array}{l}
                                  \textnormal{write output}\\
                                  \textnormal{uPrev $\leftarrow$ uCur}\\
                                  \textnormal{time += dt, timestepIdx++}\\
                                  \textnormal{deal with restart and episodes }\\
                                \end{array}}
    $}
    \begin{tabular}{|l|}
      \hline
      \textbf{\textcircled{\ref{prep}}}\verb+newtonCtl_.suggestTimestepSize()+ \\
      \begin{scriptsize}Determine new time step size from number of \textsc{Newton} steps. \end{scriptsize}\\
      \textbf{called by}: timemanager.hh, implicitproblem.hh\\
      \textbf{implemented in}: newtoncontroller.hh\\
	\hline
    \end{tabular}
    {\scriptsize$\overrightarrow{}$}
    {\scriptsize$\overrightarrow{
    \begin{array}{l}
    \textnormal{timemanager.hh}\\
    \textbf{\textcircled{\ref{prep}}} \rightarrow \textbf{\textcircled{\ref{init}}}
    \end{array}
    }$}
%      \begin{tabular}{|l|}
%       \hline
%       \textbf{\textcircled{\ref{calc}}}\verb++ \\
%       \begin{scriptsize}\end{scriptsize}\\
%       \textbf{called by}:\\
%       \textbf{implemented in}: \\
% 	\hline
%      \end{tabular}
%     $\overrightarrow{\scriptsize
%     }$
}

\end{landscape}
\normalsize

\newpage
% Original pagestyle (headings and footer) were switched off, in order to get mroe space for the flowchart.
\pagestyle{scrheadings}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "dumux-handbook"
%%% End:
